// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Js_dict from "rescript/lib/es6/js_dict.js";
import * as Js_json from "rescript/lib/es6/js_json.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as PervasivesU from "rescript/lib/es6/pervasivesU.js";
import * as FetchRobusto from "./FetchRobusto.res.mjs";

function parserParaSwapResponse(response) {
  try {
    var json = JSON.parse(response);
    console.log("Raw API response: " + JSON.stringify(json));
    var obj = Js_json.decodeObject(json);
    if (obj === undefined) {
      return {
              TAG: "Error",
              _0: "Expected a JSON object"
            };
    }
    var errorJson = Js_dict.get(obj, "error");
    if (errorJson !== undefined) {
      var errorMessage = Belt_Option.getWithDefault(Js_json.decodeString(errorJson), "Unknown error");
      return {
              TAG: "Error",
              _0: "API error: " + errorMessage
            };
    }
    var priceRouteJson = Js_dict.get(obj, "priceRoute");
    if (priceRouteJson === undefined) {
      return {
              TAG: "Error",
              _0: "Missing priceRoute in response"
            };
    }
    var priceObj = Js_json.decodeObject(priceRouteJson);
    if (priceObj === undefined) {
      return {
              TAG: "Error",
              _0: "priceRoute is not an object"
            };
    }
    var destAmountOpt = Js_dict.get(priceObj, "destAmount");
    var srcAmountOpt = Js_dict.get(priceObj, "srcAmount");
    if (destAmountOpt === undefined) {
      return {
              TAG: "Error",
              _0: "Missing destAmount or srcAmount in priceRoute"
            };
    }
    if (srcAmountOpt === undefined) {
      return {
              TAG: "Error",
              _0: "Missing destAmount or srcAmount in priceRoute"
            };
    }
    var match = Js_json.decodeString(destAmountOpt);
    var match$1 = Js_json.decodeString(srcAmountOpt);
    if (match !== undefined && match$1 !== undefined) {
      return {
              TAG: "Ok",
              _0: {
                priceRoute: {
                  destAmount: match,
                  srcAmount: match$1
                }
              }
            };
    } else {
      return {
              TAG: "Error",
              _0: "Invalid destAmount or srcAmount format"
            };
    }
  }
  catch (exn){
    return {
            TAG: "Error",
            _0: "Invalid JSON"
          };
  }
}

function getSwapDetails(fromToken, toToken, amount, paraSwapUrl, slippage, userAddress) {
  var fromTokenAddress;
  switch (fromToken) {
    case "DAI" :
        fromTokenAddress = "0x6B175474E89094C44Da98b954EedeAC495271d0F";
        break;
    case "ETH" :
        fromTokenAddress = "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE";
        break;
    default:
      fromTokenAddress = PervasivesU.failwith("Unsupported fromToken: " + fromToken);
  }
  var toTokenAddress;
  switch (toToken) {
    case "DAI" :
        toTokenAddress = "0x6B175474E89094C44Da98b954EedeAC495271d0F";
        break;
    case "ETH" :
        toTokenAddress = "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE";
        break;
    default:
      toTokenAddress = PervasivesU.failwith("Unsupported toToken: " + toToken);
  }
  var queryParams = "?srcToken=" + fromTokenAddress + "&destToken=" + toTokenAddress + "&amount=" + amount + "&side=SELL&network=1&version=6.2&slippage=" + slippage + "&userAddress=" + userAddress;
  var headers = {};
  var fetchInstance = FetchRobusto.useFetch(paraSwapUrl, headers);
  return fetchInstance.get(queryParams, parserParaSwapResponse);
}

export {
  parserParaSwapResponse ,
  getSwapDetails ,
}
/* No side effect */
